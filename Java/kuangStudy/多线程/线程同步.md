# 线程同步

形成条件：队列+锁 （保证安全性）

由于同一进程的多个线程共享同一块存储空间，为了保证数据在方法中访问时的正确性，在访问时加入了锁机制（synchronized），当一个线程独占资源时，其他线程必须等待，使用后释放锁即可。

锁机制存在的问题：

- 导致其他线程挂起
- 增加上下文切换和调度延时，引起性能问题
- 优先级高的线程等待优先级低的线程释放锁，会导致优先级倒置，引起性能问题。

## 同步方法

- synchronized方法和synchronized块
- synchronized方法控制“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须调用该方法的对象锁才能执行，否则线程会阻塞，方法一旦执行，就该独占该锁，直到方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行
- 缺陷：若将一个大的方法声明为synchronized将会影响效率

### 同步块

- 同步块：synchronized（obj）{}
- obj称之为同步监视器
  - obj可以是任何对象，但是推荐使用共享资源作为同步监视器
  - 同步方法中无需指定同步监视器，应为同步方法的监视器就是this，就是这个对象本身，活儿是class
- 同步监视器的执行过程
  1. 第一个线程访问，锁定同步监视器，执行其中代码
  2. 第二个线程访问，发现同步监视器锁定，无法访问
  3. 的哥线程访问完毕，解锁同步监视器
  4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问

## 死锁

两个线程相会等待对方的资源，都停止的情形，同一个同步块拥有“两个以上的对象锁”时，就可能发生“死锁”问题。

### 死锁避免方法

- 产长死锁的四个必要条件：
  1. 互斥条件：一个资源每次只能被一个进程使用。
  2. 请求与保持条件：一个进程因请求资源而阻塞时，对方一伙的资源保持不放
  3. 不剥夺条件：进程获得的资源，在未使用完前，不能强行剥夺。
  4. 循环等待条件：若干进程之间形成一种从头到尾想接的循环等资源关系

## Lock锁

- 从JDK 5.0开始，Java提供了更强大的线程同步机制一通过 显式定义同步锁对象来实现同步。同步锁使用L ock对象充当
- java.util.concurrent.locks.Lock接C是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一-个线程对L ock对象加锁，线程开始访问共享资源之前应先获得L ock对象
- ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock,可以显式加锁、释放锁。.

### synchronized与lock的对比

- Lock是显式锁(手动开启和关闭锁，别忘记关闭锁) synchronized是隐式锁， 出了作用域自动释放
- Lock只有代码块锁，synchronized有代码块锁和方法锁
- 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)
- 优先使用顺序:
  - Lock >同步代码块(已经进入了方法体，分配了相应资源) >同步方法(在方
    法体之外)
