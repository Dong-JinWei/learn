# 线程协作

生产者和消费者模式

## 线程通信

- 应用场景：生产者和消费者问题
  - 假设仓库中只能存放- -件产品,生产者将生产出来的产品放入仓库,消费者将仓库中产品取走消费.
  - 如果仓库中没有产品,则生产者将产品放入仓库,否则停止生产并等待,直到仓库中的产品被消费者取走为止.
  - 如果仓库中放有产品,则消费者可以将产品取走消费,否则停止消费并等待,直到仓库中再次放入产品为止.

### 现成通信-分析

这是一个线程同步问题，生产者和消费者共享同一个资源

且生产者生产，消费者消费，两条线程可以互相通信，否则互不干预

### 管程法--解决方式一

利用缓冲区解决

### 信号灯法,标志位解决

设置标志位flag

## 使用线程池

- 背景:经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。
- 思路:提前创建好多个线程，放入线程池中，使用时直接获取,使用完放回池中。可以避免频繁创建销毁、现重复利用。类似生活中的公共交通工具。
- 好处:
  - 提高响应速度(减少了创建新线程的时间)
  - 降低资源消耗(重复利用线程池中线程，不需要每次都创建)
  - 便于线程管理(...)
  - corePoolSize: 核心池的大小
  - maximumPoolSize: 最大线程数
  - keepAlive Time:线程没有任务时最多保持多长时间后会终止

### ExecutorService 和Executors
- ExecutorService: 真正的线程池接口。常见子类ThreadPoolExecutor
- void execute(Runnable command) :执行任务/命令，没有返回值，-般用来执
  行Runnable
- \<T\> Future\<T\> submit(Callable\<T\> task):执行任务，有返回值，- -般 又来执行
  Callable
- void shutdown() :关闭连接池
- Executors: 工具类、线程池的工厂类,用于创建并返回不同类型的线程池
